<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Browser Console Capture - Server</title>
  <style>
    :root {
      --primary-color: #4285F4;
      --success-color: #4CAF50;
      --error-color: #F44336;
      --warning-color: #FF9800;
      --info-color: #2196F3;
      --debug-color: #9E9E9E;
      --background-color: #f9f9f9;
      --card-background: #ffffff;
      --border-color: #e0e0e0;
      --text-color: #333333;
      --text-secondary: #666666;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--background-color);
      color: var(--text-color);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border-color);
    }

    h1 {
      font-size: 24px;
      margin: 0;
    }

    .status-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .status-card {
      background-color: var(--card-background);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .status-card h2 {
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 10px;
      color: var(--text-secondary);
    }

    .status-indicator {
      display: flex;
      align-items: center;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-dot.online {
      background-color: var(--success-color);
    }

    .status-dot.offline {
      background-color: var(--error-color);
    }

    .status-text {
      font-weight: 500;
    }

    .client-count {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .logs-container {
      background-color: var(--card-background);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      overflow: hidden;
    }

    .logs-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background-color: #f5f5f5;
      border-bottom: 1px solid var(--border-color);
    }

    .logs-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
    }

    .logs-actions {
      display: flex;
      gap: 10px;
    }

    .logs-content {
      max-height: 500px;
      overflow-y: auto;
      padding: 0;
    }

    .log-table {
      width: 100%;
      border-collapse: collapse;
    }

    .log-table th {
      position: sticky;
      top: 0;
      background-color: #f5f5f5;
      padding: 10px;
      text-align: left;
      font-weight: 500;
      border-bottom: 1px solid var(--border-color);
    }

    .log-table td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-color);
      font-size: 14px;
      vertical-align: top;
    }

    .log-table tr:hover {
      background-color: #f9f9f9;
    }

    .log-type {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      color: white;
    }

    .log-type.log {
      background-color: var(--info-color);
    }

    .log-type.error {
      background-color: var(--error-color);
    }

    .log-type.warn {
      background-color: var(--warning-color);
    }

    .log-type.info {
      background-color: var(--primary-color);
    }

    .log-type.debug {
      background-color: var(--debug-color);
    }

    .log-message {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .log-url {
      font-size: 12px;
      color: var(--text-secondary);
      word-break: break-all;
    }

    .log-timestamp {
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    }

    .button.primary {
      background-color: var(--primary-color);
      color: white;
    }

    .button.secondary {
      background-color: #f1f1f1;
      color: var(--text-color);
    }

    .button:hover {
      opacity: 0.9;
    }

    .button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .connection-info {
      background-color: var(--card-background);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .connection-info h2 {
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 10px;
      color: var(--text-secondary);
    }

    .connection-url {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      word-break: break-all;
    }

    .footer {
      text-align: center;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid var(--border-color);
      color: var(--text-secondary);
      font-size: 14px;
    }

    .last-updated {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 5px;
    }

    .tab-tracking-container {
      background-color: var(--card-background);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .tab-tracking-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .tab-tracking-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
    }

    .tab-tracking-actions {
      display: flex;
      gap: 10px;
    }

    .tab-tracking-content {
      display: flex;
      flex-direction: column;
    }

    .tab-tracking-toggle {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
      margin-right: 10px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #2196F3;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    .tab-list {
      list-style: none;
      padding: 0;
    }

    .tab-item {
      display: flex;
      align-items: center;
      padding: 5px;
      border-bottom: 1px solid var(--border-color);
    }

    .tab-item:last-child {
      border-bottom: none;
    }

    @media (max-width: 768px) {
      .status-panel {
        grid-template-columns: 1fr;
      }
    }

    /* Card styles */
    .card {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      overflow: hidden;
    }
    
    .card-header {
      background-color: #f5f5f5;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e0e0e0;
    }
    
    .card-header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #333;
    }
    
    .card-actions {
      display: flex;
      align-items: center;
    }
    
    .card-body {
      padding: 20px;
    }
    
    .info-text {
      font-size: 14px;
      color: #666;
      font-style: italic;
    }
    
    /* Tab tracking toggle */
    .tab-tracking-toggle-container {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
      margin-right: 10px;
    }
    
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
    }
    
    input:checked + .slider {
      background-color: #4CAF50;
    }
    
    input:focus + .slider {
      box-shadow: 0 0 1px #4CAF50;
    }
    
    input:checked + .slider:before {
      transform: translateX(20px);
    }
    
    .slider.round {
      border-radius: 20px;
    }
    
    .slider.round:before {
      border-radius: 50%;
    }
    
    /* Tab list */
    .tab-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
    }
    
    .no-tabs {
      padding: 20px;
      text-align: center;
      color: #888;
      font-style: italic;
    }

    /* Debug panel styles */
    .debug-panel {
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      margin-bottom: 20px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .debug-panel h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .debug-entry {
      margin-bottom: 5px;
      padding: 3px 0;
      border-bottom: 1px solid #eee;
    }
    
    .debug-entry.error {
      color: #F44336;
    }
    
    .debug-entry.warning {
      color: #FF9800;
    }
    
    .debug-entry.success {
      color: #4CAF50;
    }
    
    .debug-entry.info {
      color: #2196F3;
    }
    
    .debug-toggle {
      cursor: pointer;
      font-size: 12px;
      color: #666;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Browser Console Capture Server</h1>
      <div>
        <button id="refreshBtn" class="button secondary">Refresh</button>
      </div>
    </header>

    <div class="status-panel">
      <div class="status-card">
        <h2>Server Status</h2>
        <div class="status-indicator">
          <div id="serverStatusDot" class="status-dot offline"></div>
          <span id="serverStatusText" class="status-text">Checking...</span>
        </div>
        <div class="last-updated">
          Uptime: <span id="serverUptime">-</span>
        </div>
      </div>

      <div class="status-card">
        <h2>Extension Status</h2>
        <div class="status-indicator">
          <div id="extensionStatusDot" class="status-dot offline"></div>
          <span id="extensionStatusText" class="status-text">Disconnected</span>
        </div>
        <div class="last-updated">
          Connected: <span id="browserClientCount" class="client-count">0</span> tabs
        </div>
      </div>

      <div class="status-card">
        <h2>Cursor IDE Clients</h2>
        <div id="cursorClientCount" class="client-count">0</div>
        <div class="status-text">connected clients</div>
      </div>

      <div class="status-card">
        <h2>Captured Logs</h2>
        <div id="logCount" class="client-count">0</div>
        <div class="status-text">total logs</div>
      </div>
    </div>

    <div class="connection-info">
      <h2>Connection Information</h2>
      <div>
        <strong>Browser Extension URL:</strong>
        <div id="browserExtensionUrl" class="connection-url">ws://localhost:3000?clientType=browser</div>
      </div>
      <div>
        <strong>Cursor IDE URL:</strong>
        <div id="cursorIdeUrl" class="connection-url">ws://localhost:3000?clientType=cursor</div>
      </div>
      <div style="margin-top: 15px;">
        <strong>Server Configuration:</strong>
        <div style="margin-top: 10px;">
          <label for="serverPort" style="display: block; margin-bottom: 5px;">Server Port:</label>
          <div style="display: flex; gap: 10px;">
            <input type="number" id="serverPort" style="flex-grow: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" value="3000" min="1" max="65535">
            <button id="updatePortBtn" class="button primary" style="white-space: nowrap;">Update Port</button>
          </div>
          <div style="font-size: 12px; color: #666; margin-top: 5px;">
            Note: Changing the port requires restarting the server manually.
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <h2>Browser Tabs</h2>
        <div class="card-actions">
          <span class="info-text">Tabs are automatically synchronized</span>
        </div>
      </div>
      <div class="card-body">
        <div class="tab-tracking-toggle-container">
          <label class="switch">
            <input type="checkbox" id="tabTrackingToggle" checked>
            <span class="slider round"></span>
          </label>
          <span>Track all tabs</span>
        </div>
        <div id="tabList" class="tab-list">
          <div class="no-tabs">No tabs available. Connect the browser extension to see tabs.</div>
        </div>
      </div>
    </div>

    <div class="logs-container">
      <div class="logs-header">
        <h3 class="logs-title">Console Logs</h3>
        <div class="logs-actions">
          <button id="clearLogsBtn" class="button secondary">Clear Logs</button>
          <button id="autoScrollToggle" class="button secondary">Auto-scroll: ON</button>
        </div>
      </div>
      <div class="logs-content">
        <table class="log-table">
          <thead>
            <tr>
              <th style="width: 80px;">Type</th>
              <th>Message</th>
              <th style="width: 180px;">Timestamp</th>
            </tr>
          </thead>
          <tbody id="logsTableBody">
            <tr>
              <td colspan="3" style="text-align: center; padding: 20px;">No logs captured yet</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="footer">
      <p>Browser Console Capture Server</p>
      <div class="last-updated">
        Last updated: <span id="lastUpdated">-</span>
      </div>
    </div>

    <!-- Add debug panel after the footer -->
    <div class="debug-panel" id="debugPanel" style="display: none;">
      <h3>
        Connection Debug
        <span class="debug-toggle" id="clearDebugBtn">Clear</span>
      </h3>
      <div id="debugEntries"></div>
    </div>
  </div>

  <script>
    // DOM elements
    const serverStatusDot = document.getElementById('serverStatusDot');
    const serverStatusText = document.getElementById('serverStatusText');
    const extensionStatusDot = document.getElementById('extensionStatusDot');
    const extensionStatusText = document.getElementById('extensionStatusText');
    const serverUptime = document.getElementById('serverUptime');
    const cursorClientCount = document.getElementById('cursorClientCount');
    const logCount = document.getElementById('logCount');
    const logsTableBody = document.getElementById('logsTableBody');
    const lastUpdated = document.getElementById('lastUpdated');
    const refreshBtn = document.getElementById('refreshBtn');
    const clearLogsBtn = document.getElementById('clearLogsBtn');
    const autoScrollToggle = document.getElementById('autoScrollToggle');
    const tabList = document.getElementById('tabList');
    const browserExtensionUrl = document.getElementById('browserExtensionUrl');
    const cursorIdeUrl = document.getElementById('cursorIdeUrl');
    const serverPort = document.getElementById('serverPort');
    const updatePortBtn = document.getElementById('updatePortBtn');

    // State
    let autoScroll = true;
    let logs = [];
    let tabs = [];
    let trackingMode = 'all';
    let trackedTabs = {};
    let currentPort = window.location.port || '3000';
    let wsConnection = null;

    // Debug panel elements
    const debugPanel = document.getElementById('debugPanel');
    const debugEntries = document.getElementById('debugEntries');
    const clearDebugBtn = document.getElementById('clearDebugBtn');
    
    // Debug logging
    let debugEnabled = false;
    let debugEntryCount = 0;
    const MAX_DEBUG_ENTRIES = 100;

    // Initialize connection URLs
    function updateConnectionUrls() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.hostname;
      const port = currentPort;
      
      browserExtensionUrl.textContent = `${protocol}//${host}:${port}?clientType=browser`;
      cursorIdeUrl.textContent = `${protocol}//${host}:${port}?clientType=cursor`;
      
      // Update server port input
      serverPort.value = port;
    }

    // Format timestamp
    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString() + '.' + date.getMilliseconds().toString().padStart(3, '0');
    }

    // Format duration
    function formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      return `${hours}h ${minutes}m ${secs}s`;
    }

    // Update server status
    function updateServerStatus() {
      addDebugEntry('Fetching server status via HTTP', 'info');
      fetch('/api/status')
        .then(response => {
          if (!response.ok) {
            throw new Error('Server not responding');
          }
          
          return response.json();
        })
        .then(data => {
          addDebugEntry(`Received HTTP status: Browser: ${data.browserClients}, Cursor: ${data.cursorClients}`, 'info');
          
          // Update server status indicators
          if (data.serverStatus === 'online') {
            serverStatusDot.classList.remove('offline');
            serverStatusDot.classList.add('online');
            serverStatusText.textContent = 'Online';
          } else {
            serverStatusDot.classList.remove('online');
            serverStatusDot.classList.add('offline');
            serverStatusText.textContent = 'Offline';
          }
          
          // Update extension status indicators
          if (data.browserClients > 0) {
            extensionStatusDot.classList.remove('offline');
            extensionStatusDot.classList.add('online');
            extensionStatusText.textContent = 'Connected';
            addDebugEntry('Extension status updated to Connected via HTTP', 'success');
          } else {
            extensionStatusDot.classList.remove('online');
            extensionStatusDot.classList.add('offline');
            extensionStatusText.textContent = 'Disconnected';
            addDebugEntry('Extension status updated to Disconnected via HTTP', 'warning');
          }
          
          // Update client counts
          document.getElementById('browserClientCount').textContent = data.browserClients;
          cursorClientCount.textContent = data.cursorClients;
          logCount.textContent = data.logs || 0;
          
          // Update server uptime if available
          if (data.uptime) {
            serverUptime.textContent = formatDuration(data.uptime);
          }
          
          // Update last updated timestamp
          lastUpdated.textContent = new Date().toLocaleString();
        })
        .catch(error => {
          console.error('Error fetching server status:', error);
          addDebugEntry(`Error fetching status: ${error.message}`, 'error');
          
          // Update server status indicators to show offline
          serverStatusDot.classList.remove('online');
          serverStatusDot.classList.add('offline');
          serverStatusText.textContent = 'Offline';
          
          // Update extension status indicators to show offline
          extensionStatusDot.classList.remove('online');
          extensionStatusDot.classList.add('offline');
          extensionStatusText.textContent = 'Disconnected';
          
          // Update last updated timestamp
          lastUpdated.textContent = new Date().toLocaleString();
        });
    }

    // Fetch logs
    function fetchLogs() {
      fetch('/api/logs')
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to fetch logs');
          }
          return response.json();
        })
        .then(data => {
          logs = data.logs;
          updateLogsTable();
        })
        .catch(error => {
          console.error('Error fetching logs:', error);
        });
    }

    // Update logs table
    function updateLogsTable() {
      if (logs.length === 0) {
        logsTableBody.innerHTML = `
          <tr>
            <td colspan="3" style="text-align: center; padding: 20px;">No logs captured yet</td>
          </tr>
        `;
        return;
      }
      
      // Clear table
      logsTableBody.innerHTML = '';
      
      // Add logs to table
      logs.forEach(log => {
        const row = document.createElement('tr');
        
        // Type cell
        const typeCell = document.createElement('td');
        const typeSpan = document.createElement('span');
        typeSpan.className = `log-type ${log.type}`;
        typeSpan.textContent = log.type;
        typeCell.appendChild(typeSpan);
        
        // Message cell
        const messageCell = document.createElement('td');
        
        // Message content
        const messageDiv = document.createElement('div');
        messageDiv.className = 'log-message';
        messageDiv.textContent = log.message;
        messageCell.appendChild(messageDiv);
        
        // URL
        const urlDiv = document.createElement('div');
        urlDiv.className = 'log-url';
        urlDiv.textContent = log.url;
        messageCell.appendChild(urlDiv);
        
        // Timestamp cell
        const timestampCell = document.createElement('td');
        timestampCell.className = 'log-timestamp';
        timestampCell.textContent = formatTimestamp(log.timestamp);
        
        // Add cells to row
        row.appendChild(typeCell);
        row.appendChild(messageCell);
        row.appendChild(timestampCell);
        
        // Add row to table
        logsTableBody.appendChild(row);
      });
      
      // Auto-scroll to bottom if enabled
      if (autoScroll) {
        const logsContent = document.querySelector('.logs-content');
        logsContent.scrollTop = logsContent.scrollHeight;
      }
    }

    // Fetch tabs
    function fetchTabs() {
      // Show loading state
      tabList.innerHTML = `
        <div class="tab-item" style="justify-content: center; color: #888;">
          Loading tabs...
        </div>
      `;
      
      // First check if we have a WebSocket connection and can get tabs that way
      if (tabs && tabs.length > 0) {
        // If we already have tabs from WebSocket, use those
        updateTabList();
        
        // Still fetch settings to make sure they're up to date
        fetch('/api/tabs/settings')
          .then(response => {
            if (!response.ok) {
              throw new Error('Failed to fetch tab tracking settings');
            }
            return response.json();
          })
          .then(data => {
            if (data.success) {
              trackingMode = data.trackingMode;
              trackedTabs = data.trackedTabs;
              
              // Update tracking mode radios
              document.querySelector(`input[name="trackingMode"][value="${trackingMode}"]`).checked = true;
              
              // Update tab list
              updateTabList();
            }
          })
          .catch(error => {
            console.error('Error fetching tab settings:', error);
          });
          
        return;
      }
      
      // Fetch tabs from API with a longer timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 6000); // 6 second timeout (increased from 3 seconds)
      
      fetch('/api/tabs', { signal: controller.signal })
        .then(response => {
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`Failed to fetch tabs: ${response.status} ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          if (data.success) {
            tabs = data.tabs || [];
            console.log(`Received ${tabs.length} tabs from server`);
            
            // Fetch tab tracking settings
            return fetch('/api/tabs/settings');
          } else {
            throw new Error('Failed to fetch tabs: ' + data.message);
          }
        })
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to fetch tab tracking settings');
          }
          return response.json();
        })
        .then(data => {
          if (data.success) {
            trackingMode = data.trackingMode;
            trackedTabs = data.trackedTabs;
            
            // Update tracking mode radios
            const trackingModeRadio = document.querySelector(`input[name="trackingMode"][value="${trackingMode}"]`);
            if (trackingModeRadio) {
              trackingModeRadio.checked = true;
            }
            
            // Update tab list
            updateTabList();
          } else {
            throw new Error('Failed to fetch tab tracking settings: ' + data.message);
          }
        })
        .catch(error => {
          console.error('Error fetching tabs:', error);
          
          // For AbortError, try again with a direct fetch without timeout
          if (error.name === 'AbortError') {
            console.log('Fetch aborted, trying again without timeout');
            fetch('/api/tabs')
              .then(response => response.json())
              .then(data => {
                if (data.success) {
                  tabs = data.tabs || [];
                  console.log(`Received ${tabs.length} tabs from server on retry`);
                  updateTabList();
                }
              })
              .catch(retryError => {
                console.error('Error on retry fetch:', retryError);
                showTabError(retryError.message);
              });
          } else {
            showTabError(error.message);
          }
        });
    }

    function showTabError(message) {
      // Show error state
      const tabList = document.getElementById('tabList');
      if (tabList) {
        tabList.innerHTML = `
          <div class="tab-item" style="justify-content: center; color: #F44336;">
            Error: ${message}
          </div>
        `;
      }
    }

    // Update tab list
    function updateTabList() {
      const tabList = document.getElementById('tabList');
      const isTrackingAll = document.getElementById('tabTrackingToggle').checked;
      
      if (!tabs || tabs.length === 0) {
        tabList.innerHTML = '<div class="no-tabs-message">No tabs found</div>';
        return;
      }
      
      // Clear existing list
      tabList.innerHTML = '';
      
      // Add each tab to the list
      tabs.forEach(tab => {
        const tabItem = document.createElement('div');
        tabItem.className = 'tab-item';
        tabItem.style.display = 'flex';
        tabItem.style.alignItems = 'center';
        tabItem.style.padding = '10px';
        tabItem.style.borderBottom = '1px solid #eee';
        
        // Favicon
        const favicon = document.createElement('img');
        favicon.src = tab.favIconUrl || 'default-favicon.png';
        favicon.alt = '';
        favicon.style.width = '16px';
        favicon.style.height = '16px';
        favicon.style.marginRight = '10px';
        favicon.style.flexShrink = '0';
        
        // Tab info container
        const tabInfo = document.createElement('div');
        tabInfo.style.flexGrow = '1';
        tabInfo.style.overflow = 'hidden';
        tabInfo.style.marginRight = '10px';
        
        // Tab title
        const title = document.createElement('div');
        title.textContent = tab.title;
        title.style.fontWeight = 'bold';
        title.style.whiteSpace = 'nowrap';
        title.style.overflow = 'hidden';
        title.style.textOverflow = 'ellipsis';
        
        // Tab URL
        const url = document.createElement('div');
        url.textContent = tab.url;
        url.style.fontSize = '0.8em';
        url.style.color = '#666';
        url.style.whiteSpace = 'nowrap';
        url.style.overflow = 'hidden';
        url.style.textOverflow = 'ellipsis';
        
        // Status indicator
        const statusIndicator = document.createElement('div');
        statusIndicator.className = 'status-indicator';
        statusIndicator.style.width = '10px';
        statusIndicator.style.height = '10px';
        statusIndicator.style.borderRadius = '50%';
        statusIndicator.style.marginLeft = '10px';
        statusIndicator.style.flexShrink = '0';
        
        // Set status color based on tracking
        if (isTrackingAll) {
          statusIndicator.style.backgroundColor = '#4CAF50'; // Green for tracked
          statusIndicator.title = 'This tab is being tracked';
        } else {
          statusIndicator.style.backgroundColor = '#ccc'; // Gray for not tracked
          statusIndicator.title = 'This tab is not being tracked';
        }
        
        // Assemble the tab item
        tabInfo.appendChild(title);
        tabInfo.appendChild(url);
        tabItem.appendChild(favicon);
        tabItem.appendChild(tabInfo);
        tabItem.appendChild(statusIndicator);
        
        tabList.appendChild(tabItem);
      });
    }

    // Tab tracking toggle
    const tabTrackingToggle = document.getElementById('tabTrackingToggle');
    tabTrackingToggle.addEventListener('change', function() {
      const trackingMode = this.checked ? 'all' : 'selected';
      
      // Update UI to reflect the new tracking mode
      const toggleSlider = this.nextElementSibling;
      if (this.checked) {
        toggleSlider.style.backgroundColor = '#4CAF50';
      } else {
        toggleSlider.style.backgroundColor = '#ccc';
      }
      
      // Update the tab list to show the new tracking status
      updateTabList();
      
      // Send the new tracking mode to the server
      fetch('/api/tabs/settings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          trackingMode: trackingMode,
          trackedTabs: {}
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          console.log('Tab tracking settings updated successfully');
          
          // Show a notification
          showNotification(
            this.checked ? 'All tabs are now being tracked' : 'Tab tracking has been disabled',
            this.checked ? 'success' : 'warning'
          );
        } else {
          console.error('Failed to update tab tracking settings:', data.message);
          showNotification('Failed to update tab tracking settings', 'error');
        }
      })
      .catch(error => {
        console.error('Error updating tab tracking settings:', error);
        showNotification('Error updating tab tracking settings', 'error');
      });
    });

    // Set up WebSocket for real-time updates
    function setupWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}?clientType=viewer`;
      
      addDebugEntry(`Connecting to WebSocket: ${wsUrl}`, 'info');
      
      const ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        console.log('Connected to server via WebSocket');
        addDebugEntry('WebSocket connection established', 'success');
        
        // Store the WebSocket connection
        wsConnection = ws;
        
        // Update connection status indicator
        if (serverStatusDot && serverStatusText) {
          serverStatusDot.classList.remove('offline');
          serverStatusDot.classList.add('online');
          serverStatusText.textContent = 'Online';
          addDebugEntry('Server status updated to Online', 'info');
        }
      };
      
      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          addDebugEntry(`Received message: ${message.type}`, 'info');
          
          if (message.type === 'console_log') {
            // Add new log
            logs.push(message.data);
            updateLogsTable();
            logCount.textContent = logs.length;
            addDebugEntry(`Added console log: ${message.data.type} from ${message.data.url.substring(0, 30)}...`, 'info');
          } else if (message.type === 'status_update') {
            // Update status - this is now event-driven
            addDebugEntry(`Status update: Browser: ${message.browserClients}, Cursor: ${message.cursorClients}, Viewer: ${message.viewerClients}`, 'info');
            
            cursorClientCount.textContent = message.cursorClients;
            const browserClients = message.browserClients || 0;
            document.getElementById('browserClientCount').textContent = browserClients;
            
            // Update server status indicator
            if (message.serverStatus === 'online') {
              serverStatusDot.classList.remove('offline');
              serverStatusDot.classList.add('online');
              serverStatusText.textContent = 'Online';
              addDebugEntry('Server status updated to Online', 'info');
            } else {
              serverStatusDot.classList.remove('online');
              serverStatusDot.classList.add('offline');
              serverStatusText.textContent = 'Offline';
              addDebugEntry('Server status updated to Offline', 'warning');
            }
            
            // Update extension status indicator
            if (browserClients > 0) {
              extensionStatusDot.classList.remove('offline');
              extensionStatusDot.classList.add('online');
              extensionStatusText.textContent = 'Connected';
              addDebugEntry('Extension status updated to Connected', 'success');
            } else {
              extensionStatusDot.classList.remove('online');
              extensionStatusDot.classList.add('offline');
              extensionStatusText.textContent = 'Disconnected';
              addDebugEntry('Extension status updated to Disconnected', 'warning');
            }
            
            // Update server uptime if available
            if (message.uptime) {
              serverUptime.textContent = formatDuration(message.uptime);
            }
            
            // Update last updated timestamp
            lastUpdated.textContent = new Date().toLocaleString();
          } else if (message.type === 'logs_cleared') {
            // Clear logs
            logs = [];
            updateLogsTable();
            logCount.textContent = '0';
            addDebugEntry('Logs cleared', 'info');
          } else if (message.type === 'tabs_update') {
            // Update tabs - this is now event-driven
            addDebugEntry(`Received tabs update with ${message.tabs.length} tabs`, 'info');
            tabs = message.tabs;
            updateTabList();
          } else if (message.type === 'tab_settings_update') {
            // Update tab settings
            addDebugEntry(`Received tab settings update: ${message.trackingMode}`, 'info');
            trackingMode = message.trackingMode;
            trackedTabs = message.trackedTabs;
            
            // Update tab list
            updateTabList();
          } else if (message.type === 'welcome') {
            addDebugEntry(`Received welcome message: ${message.message}`, 'success');
            // Server acknowledged our connection - we're connected
            serverStatusDot.classList.remove('offline');
            serverStatusDot.classList.add('online');
            serverStatusText.textContent = 'Online';
            
            // Send a status request immediately after welcome
            setTimeout(() => {
              if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'request_status' }));
                addDebugEntry('Sent status request after welcome', 'info');
              }
            }, 500);
          }
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
          addDebugEntry(`Error processing message: ${error.message}`, 'error');
        }
      };
      
      ws.onclose = (event) => {
        console.log('WebSocket connection closed, attempting to reconnect...');
        addDebugEntry(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason'}, Clean: ${event.wasClean}`, 'warning');
        
        // Update server connection status indicator
        serverStatusDot.classList.remove('online');
        serverStatusDot.classList.add('offline');
        serverStatusText.textContent = 'Offline';
        
        // When server is offline, extension must be disconnected too
        extensionStatusDot.classList.remove('online');
        extensionStatusDot.classList.add('offline');
        extensionStatusText.textContent = 'Disconnected';
        
        // Clear the WebSocket reference
        wsConnection = null;
        
        // Attempt to reconnect
        setTimeout(setupWebSocket, 3000);
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        addDebugEntry('WebSocket error occurred', 'error');
        
        // Update connection status indicator
        if (serverStatusDot && serverStatusText) {
          serverStatusDot.classList.remove('online');
          serverStatusDot.classList.add('offline');
          serverStatusText.textContent = 'Error';
        }
      };
    }

    // Request status update from server
    function requestStatusUpdate() {
      if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
        wsConnection.send(JSON.stringify({
          type: 'request_status'
        }));
        addDebugEntry('Sent status request', 'info');
      } else {
        // Fallback to HTTP if WebSocket is not available
        addDebugEntry('WebSocket not available, using HTTP for status update', 'warning');
        updateServerStatus();
      }
    }

    // Request tabs from server
    function requestTabs() {
      // This function is kept for internal use only
      if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
        console.log('Tabs are automatically synchronized - no manual request needed');
      } else {
        // Fallback to HTTP if WebSocket is not available
        fetchTabs();
      }
    }

    // Refresh data
    function refreshData() {
      // Use WebSocket for real-time updates if available
      if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
        requestStatusUpdate();
        // No need to manually request tabs - they are automatically synchronized
      } else {
        // Fallback to HTTP
        updateServerStatus();
        fetchLogs();
        fetchTabs();
      }
    }

    // Clear logs
    function clearLogs() {
      fetch('/api/logs/clear', {
        method: 'POST'
      })
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to clear logs');
          }
          return response.json();
        })
        .then(data => {
          logs = [];
          updateLogsTable();
          logCount.textContent = '0';
        })
        .catch(error => {
          console.error('Error clearing logs:', error);
          alert('Failed to clear logs: ' + error.message);
        });
    }

    // Toggle auto-scroll
    function toggleAutoScroll() {
      autoScroll = !autoScroll;
      autoScrollToggle.textContent = `Auto-scroll: ${autoScroll ? 'ON' : 'OFF'}`;
    }

    // Event listeners
    refreshBtn.addEventListener('click', refreshData);
    clearLogsBtn.addEventListener('click', clearLogs);
    autoScrollToggle.addEventListener('click', toggleAutoScroll);
    
    // Add event listeners for tracking mode radios
    document.querySelectorAll('input[name="trackingMode"]').forEach(radio => {
      radio.parentElement.remove();
    });

    // Show notification
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.style.position = 'fixed';
      notification.style.bottom = '20px';
      notification.style.right = '20px';
      notification.style.padding = '12px 20px';
      notification.style.borderRadius = '4px';
      notification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.1)';
      notification.style.zIndex = '1000';
      notification.style.maxWidth = '300px';
      notification.style.animation = 'fadeIn 0.3s, fadeOut 0.3s 2.7s';
      notification.style.fontWeight = '500';
      
      // Set colors based on type
      if (type === 'success') {
        notification.style.backgroundColor = '#E8F5E9';
        notification.style.color = '#4CAF50';
        notification.style.borderLeft = '4px solid #4CAF50';
      } else if (type === 'error') {
        notification.style.backgroundColor = '#FFEBEE';
        notification.style.color = '#F44336';
        notification.style.borderLeft = '4px solid #F44336';
      } else if (type === 'warning') {
        notification.style.backgroundColor = '#FFF8E1';
        notification.style.color = '#FF9800';
        notification.style.borderLeft = '4px solid #FF9800';
      } else {
        notification.style.backgroundColor = '#E3F2FD';
        notification.style.color = '#2196F3';
        notification.style.borderLeft = '4px solid #2196F3';
      }
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Add CSS animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeOut {
          from { opacity: 1; transform: translateY(0); }
          to { opacity: 0; transform: translateY(20px); }
        }
      `;
      document.head.appendChild(style);
      
      // Remove notification after 3 seconds
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 3000);
    }

    // Add debug toggle to refresh button
    refreshBtn.addEventListener('contextmenu', function(e) {
      e.preventDefault();
      debugEnabled = !debugEnabled;
      debugPanel.style.display = debugEnabled ? 'block' : 'none';
      addDebugEntry(debugEnabled ? 'Debug mode enabled' : 'Debug mode disabled', 'info');
    });
    
    // Clear debug entries
    clearDebugBtn.addEventListener('click', function() {
      debugEntries.innerHTML = '';
      debugEntryCount = 0;
      addDebugEntry('Debug log cleared', 'info');
    });
    
    // Add debug entry
    function addDebugEntry(message, type = 'normal') {
      if (!debugEnabled) return;
      
      const entry = document.createElement('div');
      entry.className = `debug-entry ${type}`;
      
      const timestamp = new Date().toLocaleTimeString() + '.' + new Date().getMilliseconds().toString().padStart(3, '0');
      entry.textContent = `[${timestamp}] ${message}`;
      
      debugEntries.insertBefore(entry, debugEntries.firstChild);
      debugEntryCount++;
      
      // Limit the number of entries
      if (debugEntryCount > MAX_DEBUG_ENTRIES) {
        if (debugEntries.lastChild) {
          debugEntries.removeChild(debugEntries.lastChild);
        }
        debugEntryCount = MAX_DEBUG_ENTRIES;
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize connection URLs
      currentPort = window.location.port || '3000';
      updateConnectionUrls();
      
      // Set up port update button
      updatePortBtn.addEventListener('click', () => {
        const newPort = serverPort.value;
        if (newPort && !isNaN(newPort) && newPort > 0 && newPort <= 65535) {
          currentPort = newPort;
          updateConnectionUrls();
          showNotification(`Port updated to ${newPort}. You need to restart the server manually for this change to take effect.`, 'info');
        } else {
          showNotification('Please enter a valid port number (1-65535).', 'error');
          serverPort.value = currentPort;
        }
      });
      
      // Initial data fetch (will be updated by events after connection)
      refreshData();
      
      // Set up WebSocket for event-driven updates
      setupWebSocket();
      
      // Show notification about automatic tab synchronization
      setTimeout(() => {
        showNotification('Tabs are now automatically synchronized with the browser extension', 'info');
      }, 1000);
      
      // Refresh data periodically as a fallback only
      setInterval(refreshData, 60000); // Every minute as a fallback
      
      // Check WebSocket connection every 15 seconds and reconnect if needed
      setInterval(() => {
        if (!wsConnection || wsConnection.readyState !== WebSocket.OPEN) {
          addDebugEntry('WebSocket not connected, attempting to reconnect...', 'warning');
          setupWebSocket();
        } else {
          // Send a ping to keep the connection alive
          requestStatusUpdate();
        }
      }, 15000);
    });
  </script>
</body>
</html> 